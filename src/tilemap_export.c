//
// tilemap_export.c
//

#include <stdio.h>
#include <string.h>

#include "tilemap_export.h"


 #define CALC_REM_LEN() if (len <= max_len) len_rem = max_len - len; else len_rem = 0;

// Returns string length
// If the string to write exceeds max_len then it will get cropped and return an error
uint32_t tilemap_export_c_source_to_string(char * p_dest_str, uint32_t max_len, tile_map_data * p_map, tile_set_data * p_tile_set) {

    uint32_t   len, len_rem;
    uint32_t   idx;

    len = 0;

    if(p_dest_str == NULL)
        return (0); // return zero length for string

    // Update remaining length, avoid negative wraparound
    CALC_REM_LEN();

    len += (uint32_t)snprintf((p_dest_str + len), len_rem,
            "\n"
            "// Tilemap Source File \n"
            "// This file generated by: Gimp Tilemap Helper Plugin\n"
            "\n"
            "#define MAP_WIDTH_TILES %d\n"
            "#define MAP_HEIGHT_TILES %d\n"
            "#define MAP_WIDTH_PIXELS %d\n"
            "#define MAP_HEIGHT_PIXELS %d\n"
            "#define MAP_ENTRIES %d\n"
            "#define TILE_WIDTH %d\n"
            "#define TILE_HEIGHT %d\n"
            "\n"
            "const %s map[] = \n"
            "{\n",
            p_map->width_in_tiles,
            p_map->height_in_tiles,
            p_map->map_width,
            p_map->map_height,
            p_map->size,
            p_map->tile_width,
            p_map->tile_height,
            (p_tile_set->tile_count <= 255) ? "unsigned char" : "unsigned int"
            );

    // Write all the Tile Map data to a file
    for (idx = 0; idx < p_map->size; idx++) {

            // Update remaining length, avoid negative wraparound
            CALC_REM_LEN();
            len += snprintf((p_dest_str + len), len_rem, "%3d,", p_map->tile_id_list[idx]);

        if (idx && (((idx+1) % 16) == 0)) {
            // Update remaining length, avoid negative wraparound
            CALC_REM_LEN();
            len += snprintf((p_dest_str + len), len_rem, "\n"); // Line break every 8 tiles
        }

        if (idx && (((idx+1) % 64) == 0)) {
            // Update remaining length, avoid negative wraparound
            CALC_REM_LEN();
            len += snprintf((p_dest_str + len), len_rem, "\n"); // An extra line break every 64 tiles
        }
    }

    // Close the array
    CALC_REM_LEN();
    len += snprintf((p_dest_str + len), len_rem, "};\n");



    // If the flip x/y option was enabled, then write out the per-map-entry attribute data
    if (p_map->search_mask) {

        CALC_REM_LEN();
        len += (uint32_t)snprintf((p_dest_str + len), len_rem,
                "\n\n\nconst unsigned int map_attribs[] = \n"
                "{\n"
                );

        // Write all the Tile Map Attrib data to a file
        for (idx = 0; idx < p_map->size; idx++) {

                // Update remaining length, avoid negative wraparound
                CALC_REM_LEN();
                len += snprintf((p_dest_str + len), len_rem, "%4x,", p_map->tile_attribs_list[idx]);

            if (idx && (((idx+1) % 16) == 0)) {
                // Update remaining length, avoid negative wraparound
                CALC_REM_LEN();
                len += snprintf((p_dest_str + len), len_rem, "\n"); // Line break every 8 tiles
            }

            if (idx && (((idx+1) % 64) == 0)) {
                // Update remaining length, avoid negative wraparound
                CALC_REM_LEN();
                len += snprintf((p_dest_str + len), len_rem, "\n"); // An extra line break every 64 tiles
            }
        }

        // Close the array
        CALC_REM_LEN();
        len += snprintf((p_dest_str + len), len_rem, "};\n");

    }

    return (len);
}



