//
// tilemap_export.c
//

#include <stdio.h>
#include <string.h>

#include "tilemap_export.h"


 #define CALC_REM_LEN() if (len <= max_len) len_rem = max_len - len; else len_rem = 0;

// Returns string length
// If the string to write exceeds max_len then it will get cropped and return an error
uint32_t tilemap_export_c_source_to_string(char * p_dest_str, uint32_t max_len, tile_map_data * p_map, tile_set_data * p_tile_set) {

    uint32_t   len, len_rem;
    uint32_t   idx;

    len = 0;

    if(p_dest_str == NULL)
        return (0); // return zero length for string

    // Update remaining length, avoid negative wraparound
    CALC_REM_LEN();

    len += (uint32_t)snprintf((p_dest_str + len), len_rem,
            "\n"
            "// Tilemap Source File \n"
            "// This file generated by: Gimp Tilemap Helper Plugin\n"
            "\n"
            "#define MAP_WIDTH_TILES %d\n"
            "#define MAP_HEIGHT_TILES %d\n"
            "#define MAP_WIDTH_PIXELS %d\n"
            "#define MAP_HEIGHT_PIXELS %d\n"
            "#define MAP_ENTRIES %d\n"
            "#define TILE_WIDTH %d\n"
            "#define TILE_HEIGHT %d\n"
            "\n"
            "const %s map[] = \n"
            "{\n",
            p_map->width_in_tiles,
            p_map->height_in_tiles,
            p_map->map_width,
            p_map->map_height,
            p_map->size,
            p_map->tile_width,
            p_map->tile_height,
            (p_tile_set->tile_count <= 255) ? "unsigned char" : "unsigned int"
            );

    // Write all the Tile Map data to a file
    for (idx = 0; idx < p_map->size; idx++) {

            // Update remaining length, avoid negative wraparound
            CALC_REM_LEN();
            len += snprintf((p_dest_str + len), len_rem, "%3d,", p_map->tile_id_list[idx]);

        if (idx && (((idx+1) % 16) == 0)) {
            // Update remaining length, avoid negative wraparound
            CALC_REM_LEN();
            len += snprintf((p_dest_str + len), len_rem, "\n"); // Line break every 8 tiles
        }

        if (idx && (((idx+1) % 64) == 0)) {
            // Update remaining length, avoid negative wraparound
            CALC_REM_LEN();
            len += snprintf((p_dest_str + len), len_rem, "\n"); // An extra line break every 64 tiles
        }
    }

    // Close the array
    CALC_REM_LEN();
    len += snprintf((p_dest_str + len), len_rem, "};\n");



    // If the flip x/y option was enabled, then write out the per-map-entry attribute data
    if (p_map->search_mask) {

        CALC_REM_LEN();
        len += (uint32_t)snprintf((p_dest_str + len), len_rem,
                "\n\n\nconst unsigned int map_attribs[] = \n"
                "{\n"
                );

        // Write all the Tile Map Attrib data to a file
        for (idx = 0; idx < p_map->size; idx++) {

                // Update remaining length, avoid negative wraparound
                CALC_REM_LEN();
                len += snprintf((p_dest_str + len), len_rem, "%4x,", p_map->tile_attribs_list[idx]);

            if (idx && (((idx+1) % 16) == 0)) {
                // Update remaining length, avoid negative wraparound
                CALC_REM_LEN();
                len += snprintf((p_dest_str + len), len_rem, "\n"); // Line break every 8 tiles
            }

            if (idx && (((idx+1) % 64) == 0)) {
                // Update remaining length, avoid negative wraparound
                CALC_REM_LEN();
                len += snprintf((p_dest_str + len), len_rem, "\n"); // An extra line break every 64 tiles
            }
        }

        // Close the array
        CALC_REM_LEN();
        len += snprintf((p_dest_str + len), len_rem, "};\n");

    }

    return (len);
}



/*

int32_t tilemap_export_c_source_save(const char * filename, tile_map_data * tile_map, tile_set_data * tile_set) {

    int t,c;
    FILE * file;

    char path_without_filename[STR_FILENAME_MAX];

    char filename_tiles_c[STR_FILENAME_MAX];
    char filename_tiles_h[STR_FILENAME_MAX];
    char filename_map_c[STR_FILENAME_MAX];
    char filename_map_h[STR_FILENAME_MAX];

printf("Writing to C source files...\n");

    // TODO: resume honoring requested filename for output

    // snprintf(filename_tiles_c, STR_FILENAME_MAX, "%s.tiles.b3.c", filename);
    // snprintf(filename_tiles_h, STR_FILENAME_MAX, "%s.tiles.h",    filename);

    // snprintf(filename_map_c,   STR_FILENAME_MAX, "%s.map.b3.c", filename);
    // snprintf(filename_map_h,   STR_FILENAME_MAX, "%s.map.h",    filename);

    if (!get_path_without_filename(filename, path_without_filename, STR_FILENAME_MAX)) {
      return (false);
    }


    // snprintf(filename_tiles_c, STR_FILENAME_MAX, "%stiles.b3.c", path_without_filename);
    // snprintf(filename_tiles_h, STR_FILENAME_MAX, "%stiles.h",    path_without_filename);
    // printf("%s\n", filename_tiles_c);
    // printf("%s\n", filename_tiles_h);

    snprintf(filename_map_c,   STR_FILENAME_MAX, "%smap.c", path_without_filename);
    snprintf(filename_map_h,   STR_FILENAME_MAX, "%smap.h",    path_without_filename);
    printf("%s\n", filename_map_c);
    printf("%s\n", filename_map_h);



printf("// ==== TILE MAP C SOURCE FILE ====\n");

    // Open the file
    file = fopen(filename_map_c, "w");

    if(!file)
        return (false);

    fprintf(file, "/*%s \n\
    \n\
    Tilemap Source File \n\
    Map size      : %d x %d \n\
    Map entries   : %d \n\
    This file generated by: Gimp Tilemap Helper Plugin\n\
    \n\
    \n\
    const %s map[] = \n\
    {\n",get_filename_from_path(filename_map_c),
        tile_map->width_in_tiles,
        tile_map->height_in_tiles,
        tile_map->size,
        if (p_tile_set->tile_count <= 255) "unsigned char" else "unsigned int",
        tile_map->width_in_tiles,
        tile_map->height_in_tiles);

    // Write all the Tile Map data to a file
    for (t = 0; t < tile_map->size; t++) {

        fprintf(file, " %5d,", tile_map->tile_id_list[t]);

        if (t && (((t+1) % 16) == 0))
            fprintf(file, "\n"); // Line break every 8 tiles

        if (t && (((t+1) % 64) == 0))
            fprintf(file, "\n"); // Bigger line break every 64 tiles
    }


    // Close the array
    fprintf(file, " };\n");

    // Close the file
    fclose(file);




printf("// ==== TILE MAP C HEADER FILE ====\n");
    // ==== TILE MAP C HEADER FILE ====

    // Open the file
    // file = fopen(filename_map_h, "w");
    // if(!file)
    //     return (false);

    // fprintf(file, "%s \n\
    // Tilemap Include File \n\
    // Map size      : %d x %d \n\
    // Map entries   : %d \n\
    // This file generated by: Gimp Tilemap Helper Plugin\n\
    // \n\
    // \n\
    // #define MAP_WIDTH %d\n\
    // #define MAP_HEIGHT %d\n\
    // #define MAP_ENTRIES %d\n\
    \n\
    extern %s map[];\n\
    \n",get_filename_from_path(filename_map_c),
        tile_map->width_in_tiles,
        tile_map->height_in_tiles,
        tile_map->size,
        if (p_tile_set->tile_count <= 255) "unsigned char" else "unsigned int",
        tile_map->width_in_tiles,
        tile_map->height_in_tiles,
        tile_map->size);

    // Close the file
    fclose(file);



    return (true);
}

*/


/*

printf("// ==== TILE SET C SOURCE FILE ====\n");
    // ==== TILE SET C SOURCE FILE ====

    // Open the file
    file = fopen(filename_tiles_c, "w");
    if(!file)
        return (false);

    //snprintf(str_header_info, STR_HEADER_MAX, "/*
    fprintf(file, "/*\n\nFilename: %s \n\
     \n\
     Tile Source File\n\
     \n\
     Info:\n\
      Form                 : All tiles as one unit\n\
      Format               : Gameboy 4 color\n\
      Compression          : None\n\
      Counter              : None\n\
      Tile size            : %d x %d\n\
      Tiles                : 0 to %d\n\
      \n\
      Palette colors       : None\n\
      SGB Palette          : None\n\
      CGB Palette          : None\n\
      \n\
      Convert to metatiles : No\n\
      \n\
      This file was generated by: Gimp Tilemap Plugin\n\
      \n\
      \n\
      \n\
    // Start of tile array \n\
    const unsigned  char tiles[] =\n\
    {\n", get_filename_from_path(filename_tiles_c),
    tile_set->tile_width,
    tile_set->tile_height,
    tile_set->tile_count);

    // Write all the tile set data to a file
    for (t = 0; t < tile_set->tile_count; t++) {
        // Write the tile if it has data
        if (tile_set->tiles[t].p_img_encoded) {

            for (c = 0; c < tile_set->tiles[t].encoded_size_bytes; c++) {
                fprintf(file, " 0x%02x,", tile_set->tiles[t].p_img_encoded[c]);

                if (c && (((c+1) % 8) == 0))
                    fprintf(file, "\n"); // Periodic line break
            }
            fprintf(file, "\n"); // Line break between every tile
        }
    }

    // Close the array
    fprintf(file, " };\n");

    // Close the file
    fclose(file);


printf("// ==== TILE SET C HEADER FILE ====\n");
    // ==== TILE SET C HEADER FILE ====

    // Open the file
    file = fopen(filename_tiles_h, "w");
    if(!file)
        return (false);

    fprintf(file, "\n\n
    //Filename: %s \n\
    // \n\
    // Tile Header File\n\
    \n\
    \n\
    // Bank of tiles \n\
    #define tilesBank 0\n\
    \n\
    // Start of tile array/\n\
    extern unsigned char tiles[];\n\
    \n",get_filename_from_path(filename_tiles_h));

    // Close the file
    fclose(file);


*/